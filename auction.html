<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MyAuction Interface</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.3.4/dist/web3.min.js"></script>
    <style>
      /* Simple styling for clarity */
      label {
        margin-right: 10px;
      }
      div {
        margin-bottom: 20px;
      }
    </style>
  </head>

  <body>
    <h2>MyAuction</h2>

    <button onclick="connectMetamask()">Connect to MetaMask</button>
    <div id="error" style="color: red"></div>

    <div id="auctionUI" style="display: none">
      <!-- Display current highest bid and bidder -->
      <div>
        <strong>Highest Bidder:</strong>
        <span id="highestBidder">Loading...</span>
        <button onclick="fetchHighestBidder()">Refresh</button>
        <br />
        <strong>Highest Bid:</strong>
        <span id="highestBid">Loading...</span> ETH
        <button onclick="fetchHighestBid()">Refresh</button>
      </div>

      <!-- Place a bid -->
      <div>
        <h3>Place a Bid</h3>
        <label for="bidAmount">Bid Amount (in ETH):</label>
        <input type="text" id="bidAmount" />
        <button onclick="placeBid()">Place Bid</button>
      </div>

      <!-- Withdraw a bid -->
      <div>
        <h3>Withdraw Bid</h3>
        <button onclick="withdrawBid()">Withdraw Your Bid</button>
      </div>

      <!-- End the auction -->
      <div>
        <h3>End Auction (Only Beneficiary)</h3>
        <button onclick="endAuction()">End Auction</button>
      </div>
    </div>

    <script>
      let web3;
      // get contract address and ABI from remix.io
      const contractAddress = "0x51b515145103dc7bb04FB877E352C2710d69F7d1"; // Replace with your deployed contract address
      const contractABI = [
        {
          inputs: [
            {
              internalType: "uint256",
              name: "biddingTime",
              type: "uint256",
            },
            {
              internalType: "address payable",
              name: "beneficiaryAddress",
              type: "address",
            },
          ],
          stateMutability: "nonpayable",
          type: "constructor",
        },
        {
          inputs: [],
          name: "AuctionAlreadyEnded",
          type: "error",
        },
        {
          inputs: [],
          name: "AuctionEndAlreadyCalled",
          type: "error",
        },
        {
          inputs: [],
          name: "AuctionNotYetEnded",
          type: "error",
        },
        {
          inputs: [
            {
              internalType: "uint256",
              name: "highestBid",
              type: "uint256",
            },
          ],
          name: "BidNotHighEnough",
          type: "error",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "winner",
              type: "address",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
          ],
          name: "AuctionEnded",
          type: "event",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: false,
              internalType: "address",
              name: "bidder",
              type: "address",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
          ],
          name: "HighestBidIncreased",
          type: "event",
        },
        {
          inputs: [],
          name: "auctionEnd",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "auctionEndTime",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "beneficiary",
          outputs: [
            {
              internalType: "address payable",
              name: "",
              type: "address",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "bid",
          outputs: [],
          stateMutability: "payable",
          type: "function",
        },
        {
          inputs: [],
          name: "highestBid",
          outputs: [
            {
              internalType: "uint256",
              name: "",
              type: "uint256",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "highestBidder",
          outputs: [
            {
              internalType: "address",
              name: "",
              type: "address",
            },
          ],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "withdraw",
          outputs: [
            {
              internalType: "bool",
              name: "",
              type: "bool",
            },
          ],
          stateMutability: "nonpayable",
          type: "function",
        },
      ]; // Replace with ABI of your contract

      async function connectMetamask() {
        if (typeof window.ethereum !== "undefined") {
          web3 = new Web3(window.ethereum);
          try {
            await window.ethereum.request({ method: "eth_requestAccounts" });
            initAuctionInterface();
          } catch (error) {
            document.getElementById("error").innerText =
              "Error connecting to MetaMask.";
          }
        } else {
          document.getElementById("error").innerText =
            "Please install MetaMask to use this interface.";
        }
      }

      function initAuctionInterface() {
        document.getElementById("auctionUI").style.display = "block";
        // Load initial data
        refreshData();
      }

      async function refreshData() {
        const auction = new web3.eth.Contract(contractABI, contractAddress);
        const highestBid = await auction.methods.highestBid().call();
        const highestBidder = await auction.methods.highestBidder().call();

        document.getElementById("highestBid").innerText = web3.utils.fromWei(
          highestBid,
          "ether"
        );
        document.getElementById("highestBidder").innerText = highestBidder;
      }
      function displayError(error) {
        document.getElementById("error").innerText = "Error: " + error.message;
      }

      async function placeBid() {
        const bidAmount = document.getElementById("bidAmount").value;
        const accounts = await web3.eth.getAccounts();

        const auction = new web3.eth.Contract(contractABI, contractAddress);
        auction.methods
          .bid()
          .send({
            from: accounts[0],
            value: web3.utils.toWei(bidAmount, "ether"),
          })
          .then(refreshData)
          .catch((error) => displayError(error));
      }

      async function withdrawBid() {
        const accounts = await web3.eth.getAccounts();

        const auction = new web3.eth.Contract(contractABI, contractAddress);
        auction.methods
          .withdraw()
          .send({ from: accounts[0] })
          .then(refreshData)
          .catch((error) => displayError(error));
      }

      async function endAuction() {
        const accounts = await web3.eth.getAccounts();

        const auction = new web3.eth.Contract(contractABI, contractAddress);
        auction.methods
          .auctionEnd()
          .send({ from: accounts[0] })
          .then(refreshData)
          .catch((error) => displayError(error));
      }

      async function fetchHighestBidder() {
        const auction = new web3.eth.Contract(contractABI, contractAddress);

        let highestBidder = 0;
        try {
          highestBidder = await auction.methods.highestBidder().call();
        } catch (error) {
          displayError(error);
        }

        document.getElementById("highestBidder").innerText = highestBidder;
      }

      async function fetchHighestBid() {
        const auction = new web3.eth.Contract(contractABI, contractAddress);
        const highestBid = await auction.methods
          .highestBid()
          .call()
          .catch((error) => displayError(error));
        document.getElementById("highestBid").innerText = web3.utils.fromWei(
          highestBid,
          "ether"
        );
      }
    </script>
  </body>
</html>
